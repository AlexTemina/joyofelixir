<section class='break'>
  <h2>Buzzwords explained</h2>

  <p>
    In this chapter, we'lll dissect what that darned Wikipedia description meant. You know the one. The one that
    perplexed us back in <a href='/ii-isnt-that-something-you-drink'>"Elixir? Isn't that something you drink?"</a>.
  </p>

  <h3>That darn Wikipedia description</h3>

  <p>
    Let's take another look at that description:
  </p>

  <blockquote>
    <p>
      Elixir is a functional, concurrent, general-purpose programming language that runs on the Erlang virtual machine
      (BEAM).
    </p>
  </blockquote>

  <p>
    Yeah, it's still not quite clear, is it? How about if we did this:
  </p>

  <blockquote>
    <p>
      Elixir is a <span class='highlight highlight-red'>functional</span>, <span
        class='highlight highlight-yellow'>concurrent</span>, <span class='highlight highlight-green'>general-purpose
        programming language</span> that runs on the <span class='highlight highlight-blue'>Erlang virtual machine
        (BEAM)</span>.
    </p>
  </blockquote>

  <p>
    This is better because we have each concept neatly isolated from all the other concepts. Let's go through them one
    by one.
  </p>

  <section>
    <h3>Functional</h3>

    <p>
      When we talk about Elixir being a "functional" language we don't mean to call it that because it operates
      correctly; using one of the traditional meanings of the word "functional". We don't mean that it "designed to be
      practical and useful, rather than attractive" &mdash; to quote the macOS dictionary &mdahs; although it certainly
      is all three of those things.
    </p>

    <p>
      What is meant by this is that Elixir does what it does with a heavy reliance on functions. <em>To understand how
        functions work is to understand how Elixir works</em>. If you've read <a href='/5-funky-functions'>Chapter 5:
        Funky Functions</a> (or further) already, you will have seen these in action. Here's the first example from that
      chapter:
    </p>

    <pre><code>iex> greeting = fn (place) -> "Hello, #{place}!" end
<span class='console-yellow'>#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;</span></code></pre>

    <p>
      In this example, a function is defined and assigned to the variable called <code>greeting</code>. This function
      performs a certain action here, in this case that action is to generate a string beginning with "Hello" and then
      finishing with a place, which we provide to the function when we run the function.
    </p>

    <p>
      Elixir doesn't do anything with the function until we run some other code to tell it to.
    </p>

    <pre><code>iex> greeting.("World")
<span class='console-green'>"Hello, World!"</span></code></pre>

    <p>
      When we run the <code>greeting</code> and pass it the string <code>"World"</code> it combines the string from
      inside the function and the string passed as an argument into one string and then returns that.
    </p>

    <p>
      This is just one little example of how Elixir uses functions to work. Another example is the built-in functions
      that we show first in <a href='/8/strings-input-and-output'>Chapter 8: Strings, input, and output</a>:
    </p>

    <pre><code>iex> String.reverse("reverse this")
<span class='console-green'>"siht esrever"</span></code></pre>

    <p>
      In this example, we're running the <code>reverse/1</code> function from the <code>String</code> module. Elixir has
      some code already defined that knows how to perform the task of reversing a string. All we need to do to use it is
      to specify the function and the required arguments and Elixir handles the rest.
    </p>

    <p>
      These are just two small examples of why Elixir is called a <em>functional</em> language. It is called a
      functional language because you use functions to make it perform actions.
    </p>
  </section>

  <section>
    <h3>Concurrent</h3>

    <p>
      When Elixir is called a "concurrent" language, it means that it can run multiple parts of a program at the same
      time. A good description of <a href='https://en.wikipedia.org/wiki/Concurrent_computing'>concurrent computing</a>
      can be found on Wikipedia.
    </p>

    <p>
      The advantage of this is that Elixir can be used to perform multiple operations all at the same time. Let's think
      of a program that needs to take a list of accounts and their transactions for a bank, and calculate the balances
      for each of the
      accounts. Think of a really, really long list full of transactions and accounts. A list that might look like this:
    </p>

    <ul>
      <li>Account 1 - Transaction 1 - $10</li>
      <li>Account 1 - Transaction 2 - $20</li>
      <li>Account 2 - Transaction 1 - $30</li>
      <li>...</li>
    </ul>

    <p>
      A non-concurrent program may read this list one item at a time, and process it that way using only a single part
      of a computer (called a "core") to do the processing.
    </p>

    <p>
      Elixir's concurrency features can be used to split reading this list into smaller tasks that can then be performed
      all at the same time. This will ultimately rely on multiple cores of the computer to do
      the reading and calculation, and will result in a much faster calculation than using only a single core.
    </p>
  </section>

  <section>
    <h3>General-purpose programming language</h3>

    <p>
      A general-purpose programming language is one that is not designed for a particular purpose, but it can be used
      across all kinds of purposes. In relation to Elixir, this means you can use Elixir to create all sorts of programs
      that do whatever you can imagine.
    </p>
  </section>

  <section>
    <h3>Erlang virtual machine (BEAM)</h3>

    <p>
      The Erlang virtual machine (BEAM) is the foundation of Elixir's power. It's a rock-solid foundation that has
      existed
      existed since 1986. Erlang provides the underlying concurrency features for Elixir, managing the low-level things
      that tell the computer how to schedule particular tasks in the most efficient way possible.
    </p>
  </section>
</section>
