<section class='major'>
  <h2 id='chapter-15'>15. Part 3: Recap</h2>

  <p>
    We now come to the end of Part 3.
  </p>

  <p>
    This part of Joy of Elixir was all about exploring the functions and other things that Elixir provides us.
  </p>

  <p>
    In this part, we introduced <em>built-in modules</em>. These are collections of functions that help us work with certain data types in Elixir. We saw the <code>String</code>, <code>List</code>, <code>Map</code>, <code>Enum</code> and <code>File</code> modules.
  </p>

  <p>
    We can chain these functions together using the <em>pipe operator</em>, as we saw back in Chapter 10. Here's an example of us chaining together two functions from the <code>String</code> module that we saw during that introduction:
  </p>

  <pre><code>iex> "hello pipe operator" |> String.upcase() |> String.reverse()</code></pre>

  <p>
    The pipe operator is one of Elixir's best features as it allows us to read the code from left-to-right, just as we would be reading this sentence.
  </p>

  <p>
    We should now have a good understanding around the fundamental building blocks that Elixir provides us. We can work with strings, lists, maps and files now, and we know where we can find these functions too.
  </p>

  <p>
    In Chapter 12 we looked at conditional statements as a way of deciding when to run a particular piece of code. We saw how we could pattern match on the function responses with <code>case</code>, use <code>cond</code> to check conditions and run code depending on that condition, and we used <code>if</code> and <code>unless</code> to perform similar checks to <code>cond</code>. Finally, we wrapped up by covering <code>with</code>, which runs code in the order we specify it in, and will only execute code if multiple conditions are met.
  </p>

  <p>
    In Chapter 13 we saw where we could find additional functions, or information about functions. We saw that IEx provides a helper called <code>h</code> that works like this:
  </p>

  <pre><code>iex> h Map.get/2</code></pre>

  <p>
    This then returns the documentation for the <code>Map.get/2</code> function:
  </p>


  <pre><code class='no-highlight custom'><div class='console-bg-yellow center'>def get(map, key, default \\ nil)</div>
    Gets the value for a specific <span class='console-blue'>key</span> in <span class='console-blue'>map</span>.

    If <span class='console-blue'>key</span> is present in <span class='console-blue'>map</span> with value <span class='console-blue'>value</span>, then value is returned. Otherwise,
    <span class='console-blue'>default</span> is returned (which is <span class='console-blue'>nil</span> unless specified otherwise).

    <span class='console-yellow'>## Examples</span><div class='console-blue'>
        iex> Map.get(%{}, :a)
        nil
        iex> Map.get(%{a: 1}, :a)
        1
        iex> Map.get(%{a: 1}, :b)
        nil
        iex> Map.get(%{a: 1}, :b, 3)
        3</div>
    </code></pre>

  <p>
    In this same chapter, we learned about navigating through IEx prompts using the arrow keys on the keyboard, as well as the <code>v</code> helper function in IEx that gives us the last value, or we could use <code>v(3)</code> to get the value from the third line of IEx.
  </p>

  <p>
    Finally in Chapter 13, we saw that there are two great documentation sites, the <a href='https://elixir-lang.org/docs.html'>official documentation</a> and <a href='https://elixirschool.com'>Elixir School</a>. You can use both of these resources to supplement your learning when you're reading this book.

  <p>
    In Chapter 14 we got to see how to create our own modules and structures (or "structs" for short). Creating modules allows us to group together similar functions, just like what is done for the <code>String</code> and <code>Map</code> built-in functions for Elixir.
  </p>

  <p>
    In the final part of this book, we're going to be looking into how we can build an Elixir project just like the pros do by using a tool called Mix. We'll be looking at how we can start a new Mix project, bring in other people's code into our project, and then finally look at how we can ensure the code that we write is always working through the process of writing automated tests for that code.
  </p>

</section>
